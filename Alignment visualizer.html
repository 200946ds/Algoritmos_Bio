<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Bioinformatics Toolkit — NW · SW · BWT</title>
<style>
@import url('https://fonts.googleapis.com/css2?family=Space+Mono:ital,wght@0,400;0,700;1,400&family=Bebas+Neue&family=Courier+Prime:wght@400;700&display=swap');

:root {
  --bg:#0a0a10; --panel:#13131c; --panel2:#1a1a26; --border:#252535;
  --accent:#ff3c3c; --accent2:#ffcc00; --green:#39ff14; --blue:#4da6ff;
  --purple:#c084fc; --text:#e8e8f0; --muted:#5a5a70;
  --path-bg:#211e00; --path-border:#ffcc00; --cell-bg:#161620;
}
*{box-sizing:border-box;margin:0;padding:0;}
body{background:var(--bg);color:var(--text);font-family:'Courier Prime',monospace;min-height:100vh;padding:20px;}
h1{font-family:'Bebas Neue',sans-serif;font-size:clamp(2rem,5vw,3.5rem);letter-spacing:.1em;color:var(--text);text-align:center;margin-bottom:4px;}
h1 span{color:var(--accent);}
.subtitle{text-align:center;color:var(--muted);font-size:.85rem;margin-bottom:22px;letter-spacing:.06em;}

.mode-tabs{display:flex;justify-content:center;gap:10px;margin-bottom:24px;flex-wrap:wrap;}
.tab-btn{font-family:'Bebas Neue',sans-serif;font-size:1.1rem;letter-spacing:.1em;padding:8px 24px;border-radius:6px;cursor:pointer;border:2px solid var(--border);background:var(--panel);color:var(--muted);transition:all .2s;}
.tab-btn.active-nw{border-color:var(--green);color:var(--green);background:rgba(57,255,20,.08);}
.tab-btn.active-sw{border-color:var(--accent);color:var(--accent);background:rgba(255,60,60,.08);}
.tab-btn.active-bwt{border-color:var(--blue);color:var(--blue);background:rgba(77,166,255,.08);}

.ctrl-panel{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:22px;max-width:780px;margin:0 auto 28px;}
.ctrl-panel label{display:block;font-size:.7rem;color:var(--muted);letter-spacing:.1em;text-transform:uppercase;margin-bottom:5px;}
.ctrl-panel input,.ctrl-panel select{width:100%;background:var(--bg);border:1px solid var(--border);border-radius:6px;color:var(--text);font-family:'Courier Prime',monospace;font-size:1rem;padding:8px 12px;transition:border-color .2s;}
.ctrl-panel input:focus,.ctrl-panel select:focus{outline:none;border-color:var(--accent);}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:14px;}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin-top:14px;}
.btn-run{width:100%;margin-top:16px;background:var(--accent);color:#fff;border:none;border-radius:8px;font-family:'Bebas Neue',sans-serif;font-size:1.4rem;letter-spacing:.1em;padding:12px;cursor:pointer;transition:background .2s,transform .1s;}
.btn-run:hover{background:#ff6060;transform:translateY(-1px);}
.btn-run.bwt-btn{background:var(--blue);color:#000;}
.btn-run.bwt-btn:hover{background:#7ec6ff;}

#output{max-width:100%;overflow-x:auto;}

.result-box{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:22px 26px;max-width:900px;margin:0 auto 24px;}
.result-box h2{font-family:'Bebas Neue',sans-serif;font-size:1.35rem;color:var(--muted);letter-spacing:.12em;margin-bottom:14px;}
.seq-line{display:flex;align-items:center;gap:10px;margin-bottom:6px;}
.seq-label{font-size:.68rem;color:var(--muted);letter-spacing:.08em;width:95px;flex-shrink:0;}
.seq-chars{display:flex;gap:5px;font-family:'Space Mono',monospace;font-size:1.25rem;font-weight:700;}
.sc{width:26px;text-align:center;padding:2px 0;border-radius:3px;}
.sc.match{color:var(--green);} .sc.mismatch{color:var(--accent);} .sc.gap{color:var(--muted);}
.match-line{display:flex;gap:5px;padding-left:105px;margin-bottom:6px;}
.ms{width:26px;text-align:center;font-size:.95rem;color:var(--green);}
.score-badge{font-family:'Bebas Neue',sans-serif;font-size:1.25rem;letter-spacing:.08em;margin-top:14px;display:inline-block;}
.score-circle{display:inline-block;width:52px;height:52px;line-height:50px;text-align:center;border:3px solid var(--accent);border-radius:50%;color:var(--accent);font-family:'Bebas Neue',sans-serif;font-size:1.8rem;margin-left:10px;vertical-align:middle;box-shadow:0 0 20px rgba(255,60,60,.4);}

.matrix-wrap{max-width:100%;overflow-x:auto;margin:0 auto 20px;}
.section-title{font-family:'Bebas Neue',sans-serif;font-size:1.35rem;color:var(--muted);letter-spacing:.12em;margin-bottom:12px;text-align:center;}
table.matrix{border-collapse:collapse;margin:0 auto;}
table.matrix th,table.matrix td{border:1px solid var(--border);text-align:center;vertical-align:middle;min-width:104px;height:90px;padding:3px;}
table.matrix th{background:#181826;font-family:'Space Mono',monospace;font-size:1rem;font-weight:700;color:var(--accent2);height:38px;min-width:104px;}
table.matrix th.rh{color:var(--green);}
table.matrix td{background:var(--cell-bg);font-family:'Courier Prime',monospace;}
table.matrix td.path-cell{background:var(--path-bg);border-color:var(--path-border);border-width:2px;}
.cell-score{font-family:'Space Mono',monospace;font-weight:700;font-size:1.25rem;display:block;margin-bottom:2px;color:var(--text);}
td.path-cell .cell-score{color:var(--accent2);}
.cell-ops{display:flex;flex-direction:column;gap:1px;align-items:flex-start;padding:0 3px;}
.co{font-size:.59rem;color:var(--muted);white-space:nowrap;line-height:1.4;font-family:'Space Mono',monospace;}
.co.chosen{color:var(--accent);font-weight:700;font-size:.61rem;}
.co.chosen-path{color:var(--accent2);font-weight:700;font-size:.63rem;}
.arrow-ind{display:block;font-size:1.2rem;line-height:1;margin-top:2px;color:var(--accent);font-weight:700;}
td.path-cell .arrow-ind{color:var(--accent2);font-size:1.4rem;}
.puntaje-final{text-align:center;margin:14px auto 30px;font-family:'Bebas Neue',sans-serif;font-size:2rem;letter-spacing:.1em;color:var(--text);}
.puntaje-final .circle{display:inline-block;width:68px;height:68px;line-height:68px;text-align:center;border:4px solid var(--accent);border-radius:50%;color:var(--accent);font-size:2.4rem;margin-left:12px;vertical-align:middle;box-shadow:0 0 28px rgba(255,60,60,.5);animation:pulse 2s infinite;}
@keyframes pulse{0%,100%{box-shadow:0 0 28px rgba(255,60,60,.5)}50%{box-shadow:0 0 50px rgba(255,60,60,.9)}}

/* BWT */
.bwt-section{background:var(--panel);border:1px solid var(--border);border-radius:12px;padding:22px;max-width:1100px;margin:0 auto 24px;}
.bwt-section h2{font-family:'Bebas Neue',sans-serif;font-size:1.3rem;color:var(--blue);letter-spacing:.1em;margin-bottom:16px;}
table.bwt-rot{border-collapse:collapse;font-family:'Space Mono',monospace;font-size:.9rem;}
table.bwt-rot th{background:#0d1520;color:var(--blue);padding:5px 10px;border:1px solid #1c2a3a;font-size:.7rem;letter-spacing:.08em;text-transform:uppercase;}
table.bwt-rot td{padding:5px 10px;border:1px solid #1c2a3a;}
table.bwt-rot tr:nth-child(even) td{background:#101820;}
table.bwt-rot tr:nth-child(odd) td{background:#0c1018;}
.bwt-f{color:var(--green);font-weight:700;} .bwt-l{color:var(--accent);font-weight:700;}
.bwt-idx{color:var(--muted);font-size:.78rem;} .bwt-mid{color:var(--text);}
.bwt-orig{background:rgba(77,166,255,.1)!important;outline:1px solid var(--blue);}
table.c-table{border-collapse:collapse;font-family:'Space Mono',monospace;margin:0 auto;}
table.c-table th{background:#0d1520;color:var(--blue);padding:6px 14px;border:1px solid #1c2a3a;font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;}
table.c-table td{padding:6px 14px;border:1px solid #1c2a3a;text-align:center;background:#0c1018;}
table.c-table td.cv{color:var(--accent2);font-weight:700;font-size:1rem;}
table.occ-table{border-collapse:collapse;font-family:'Space Mono',monospace;margin:0 auto;}
table.occ-table th{background:#0d1520;color:var(--purple);padding:5px 10px;border:1px solid #1c2a3a;font-size:.7rem;text-transform:uppercase;letter-spacing:.08em;}
table.occ-table td{padding:5px 10px;border:1px solid #1c2a3a;text-align:center;background:#0c1018;font-size:.82rem;}
table.occ-table td.occ-val{color:var(--accent2);} table.occ-table td.occ-zero{color:var(--muted);}
table.search-table{border-collapse:collapse;font-family:'Space Mono',monospace;width:100%;max-width:900px;margin:0 auto;}
table.search-table th{background:#0d1520;color:var(--green);padding:7px 12px;border:1px solid #1c2a3a;font-size:.72rem;text-transform:uppercase;letter-spacing:.08em;}
table.search-table td{padding:7px 12px;border:1px solid #1c2a3a;font-size:.83rem;background:#0c1018;}
table.search-table tr.found td{background:#0a1a0a;} table.search-table tr.not-found td{background:#1a0a0a;}
.calc-cell{color:var(--blue);font-size:.76rem;} .range-cell{color:var(--accent2);font-weight:700;}
.positions-result{text-align:center;margin-top:16px;padding:16px;background:rgba(57,255,20,.07);border:2px solid var(--green);border-radius:10px;}
.positions-result .pr-label{font-family:'Bebas Neue',sans-serif;font-size:1.3rem;color:var(--green);letter-spacing:.1em;}
.positions-result .pr-val{font-family:'Space Mono',monospace;font-size:1.5rem;color:var(--accent2);font-weight:700;margin-top:4px;}
.bwt-string{font-family:'Space Mono',monospace;font-size:1.1rem;padding:8px 14px;background:#0c1018;border-radius:6px;display:inline-block;letter-spacing:.08em;}
.bwtF{color:var(--green);font-weight:700;} .bwtL{color:var(--accent);font-weight:700;} .bwtN{color:var(--text);}
.algo-badge{display:inline-block;padding:2px 9px;border-radius:4px;font-size:.72rem;font-weight:700;letter-spacing:.08em;margin-left:8px;vertical-align:middle;}
.algo-badge.nw{background:rgba(57,255,20,.12);color:var(--green);border:1px solid var(--green);}
.algo-badge.sw{background:rgba(255,60,60,.12);color:var(--accent);border:1px solid var(--accent);}
.algo-badge.bwt{background:rgba(77,166,255,.12);color:var(--blue);border:1px solid var(--blue);}
.error-msg{color:var(--accent);text-align:center;font-size:1rem;padding:20px;font-family:'Space Mono',monospace;}
.empty-header{background:#0a0a10!important;}
.two-col{display:grid;grid-template-columns:1fr 1fr;gap:20px;}
@media(max-width:640px){.two-col{grid-template-columns:1fr;}.grid2{grid-template-columns:1fr;}}
select option{background:#1a1a24;}
</style>
</head>
<body>

<h1>BIO <span>TOOLKIT</span></h1>
<p class="subtitle">Needleman-Wunsch &nbsp;·&nbsp; Smith-Waterman &nbsp;·&nbsp; Burrows-Wheeler Transform + FM-Index</p>

<div class="mode-tabs">
  <button class="tab-btn" id="tab-nw"  onclick="setMode('NW')">NW — GLOBAL</button>
  <button class="tab-btn" id="tab-sw"  onclick="setMode('SW')">SW — LOCAL</button>
  <button class="tab-btn" id="tab-bwt" onclick="setMode('BWT')">BWT + FM-INDEX</button>
</div>

<div class="ctrl-panel" id="ctrl-align">
  <div class="grid2">
    <div><label>Secuencia Horizontal (seq1)</label>
      <input type="text" id="seq1" value="GCATTA" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z]/g,'')"></div>
    <div><label>Secuencia Vertical (seq2)</label>
      <input type="text" id="seq2" value="GCATA" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z]/g,'')"></div>
  </div>
  <div class="grid3">
    <div><label>Match</label><input type="number" id="match" value="1" step="1"></div>
    <div><label>Mismatch</label><input type="number" id="mismatch" value="-1" step="1"></div>
    <div><label>Gap</label><input type="number" id="gap" value="-2" step="1"></div>
  </div>
  <button class="btn-run" onclick="runAlign()">▶ ALINEAR</button>
</div>

<div class="ctrl-panel" id="ctrl-bwt" style="display:none">
  <div class="grid2">
    <div><label>Texto / Genoma</label>
      <input type="text" id="bwtText" value="GATTACA" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z]/g,'')"></div>
    <div><label>Patrón a buscar</label>
      <input type="text" id="bwtPattern" value="ATT" oninput="this.value=this.value.toUpperCase().replace(/[^A-Z]/g,'')"></div>
  </div>
  <button class="btn-run bwt-btn" onclick="runBWT()">▶ TRANSFORMAR Y BUSCAR</button>
</div>

<div id="output"></div>

<script>
let currentMode = 'NW';

function setMode(m) {
  currentMode = m;
  document.getElementById('ctrl-align').style.display = (m==='BWT') ? 'none' : '';
  document.getElementById('ctrl-bwt').style.display   = (m==='BWT') ? ''     : 'none';
  ['NW','SW','BWT'].forEach(t => {
    document.getElementById('tab-'+t.toLowerCase()).className =
      'tab-btn' + (t===m ? ' active-'+t.toLowerCase() : '');
  });
  document.getElementById('output').innerHTML = '';
}
setMode('NW');

// ─────────────────────────────────────────────────────
//  ALIGNMENT  (NW / SW)
// ─────────────────────────────────────────────────────
function runAlign() {
  const seq1 = document.getElementById('seq1').value.trim();
  const seq2 = document.getElementById('seq2').value.trim();
  const algo = currentMode;
  const MS = parseInt(document.getElementById('match').value)||1;
  const MM = parseInt(document.getElementById('mismatch').value)||-1;
  const GS = parseInt(document.getElementById('gap').value)||-2;

  if (!seq1||!seq2) { out('<p class="error-msg">⚠ Ingresa ambas secuencias</p>'); return; }

  const m = seq2.length, n = seq1.length;
  const dp = [];
  for (let i=0;i<=m;i++){dp[i]=[];for(let j=0;j<=n;j++)dp[i][j]={score:0,ops:[],chosenDirs:[],pathArrow:''};}

  if (algo==='NW'){
    for(let i=0;i<=m;i++) dp[i][0].score=i*GS;
    for(let j=0;j<=n;j++) dp[0][j].score=j*GS;
  }

  for(let i=1;i<=m;i++){
    for(let j=1;j<=n;j++){
      const sub = seq2[i-1]===seq1[j-1] ? MS : MM;
      const db=dp[i-1][j-1].score, ub=dp[i-1][j].score, lb=dp[i][j-1].score;
      const dv=db+sub, uv=ub+GS, lv=lb+GS;
      const ss=sub>=0?`+${sub}`:`${sub}`, gs=GS>=0?`+${GS}`:`${GS}`;
      const ops=[
        {dir:'↖',val:dv,expr:`↖ ${db}${ss}=${dv}`},
        {dir:'↑',val:uv,expr:`↑ ${ub}${gs}=${uv}`},
        {dir:'←',val:lv,expr:`← ${lb}${gs}=${lv}`},
      ];
      let mx=Math.max(dv,uv,lv);
      if(algo==='SW') mx=Math.max(mx,0);
      dp[i][j].score=mx;
      dp[i][j].ops=ops;
      dp[i][j].chosenDirs=ops.filter(o=>o.val===mx&&(algo==='NW'||mx>0)).map(o=>o.dir);
    }
  }

  const pathSet=new Set();
  let a1='',a2='';

  if(algo==='NW'){
    let i=m,j=n;
    while(i>0||j>0){
      pathSet.add(`${i},${j}`);
      const sub=seq2[i-1]===seq1[j-1]?MS:MM;
      const cur=dp[i][j].score;
      if(i>0&&j>0&&cur===dp[i-1][j-1].score+sub){dp[i][j].pathArrow='↖';a1=seq1[j-1]+a1;a2=seq2[i-1]+a2;i--;j--;}
      else if(i>0&&cur===dp[i-1][j].score+GS){dp[i][j].pathArrow='↑';a1='-'+a1;a2=seq2[i-1]+a2;i--;}
      else{dp[i][j].pathArrow='←';a1=seq1[j-1]+a1;a2='-'+a2;j--;}
    }
    pathSet.add('0,0');
  } else {
    let mx2=0,si=0,sj=0;
    for(let i=1;i<=m;i++)for(let j=1;j<=n;j++)if(dp[i][j].score>mx2){mx2=dp[i][j].score;si=i;sj=j;}
    let i=si,j=sj;
    while(i>0&&j>0&&dp[i][j].score>0){
      pathSet.add(`${i},${j}`);
      const sub=seq2[i-1]===seq1[j-1]?MS:MM;
      const cur=dp[i][j].score;
      if(cur===dp[i-1][j-1].score+sub){dp[i][j].pathArrow='↖';a1=seq1[j-1]+a1;a2=seq2[i-1]+a2;i--;j--;}
      else if(cur===dp[i-1][j].score+GS){dp[i][j].pathArrow='↑';a1='-'+a1;a2=seq2[i-1]+a2;i--;}
      else{dp[i][j].pathArrow='←';a1=seq1[j-1]+a1;a2='-'+a2;j--;}
    }
    if(i>=0&&j>=0)pathSet.add(`${i},${j}`);
  }

  const finalScore = algo==='NW' ? dp[m][n].score :
    (()=>{let mx=0;for(let i=1;i<=m;i++)for(let j=1;j<=n;j++)mx=Math.max(mx,dp[i][j].score);return mx;})();

  const badge=`<span class="algo-badge ${algo.toLowerCase()}">${algo==='NW'?'GLOBAL':'LOCAL'}</span>`;
  let html=`<div class="result-box"><h2>ALINEAMIENTO FINAL ${badge}</h2>`;
  html+=seqLine('Cadena 1 →',a1,a2)+matchLine(a1,a2)+seqLine('Cadena 2 ↓',a2,a1);
  html+=`<div style="margin-top:12px"><span class="score-badge">PUNTAJE FINAL</span><span class="score-circle">${finalScore}</span></div></div>`;

  html+=`<div class="matrix-wrap"><p class="section-title">MATRIZ DE PROGRAMACIÓN DINÁMICA</p><table class="matrix">`;
  html+=`<tr><th class="empty-header"></th><th>—</th>`;
  for(let j=0;j<n;j++)html+=`<th>${seq1[j]}</th>`;
  html+=`</tr>`;

  for(let i=0;i<=m;i++){
    html+=`<tr>${i===0?'<th class="rh">—</th>':`<th class="rh">${seq2[i-1]}</th>`}`;
    for(let j=0;j<=n;j++){
      const isP=pathSet.has(`${i},${j}`);
      const sc=dp[i][j].score;
      if(i===0||j===0){
        html+=`<td class="${isP?'path-cell':''}"><span class="cell-score">${sc}</span></td>`;
      } else {
        const {ops,chosenDirs,pathArrow}=dp[i][j];
        let oh='<div class="cell-ops">';
        for(const o of ops){
          let c2='co';
          if(isP&&pathArrow===o.dir)c2='co chosen-path';
          else if(chosenDirs.includes(o.dir))c2='co chosen';
          oh+=`<span class="${c2}">${o.expr}</span>`;
        }
        oh+='</div>';
        let ah='';
        if(pathArrow)ah=`<span class="arrow-ind">${pathArrow}</span>`;
        else if(chosenDirs.length)ah=`<span class="arrow-ind" style="font-size:.9rem">${chosenDirs.join('')}</span>`;
        html+=`<td class="${isP?'path-cell':''}"><span class="cell-score">${sc}</span>${oh}${ah}</td>`;
      }
    }
    html+=`</tr>`;
  }
  html+=`</table></div><div class="puntaje-final">PUNTAJE FINAL<span class="circle">${finalScore}</span></div>`;
  out(html);
}

function seqLine(label,seq,ref){
  let c='';
  for(let k=0;k<seq.length;k++){
    let cls='sc';
    if(seq[k]==='-')cls+=' gap';
    else if(ref&&ref[k]!=='-'&&seq[k]===ref[k])cls+=' match';
    else cls+=' mismatch';
    c+=`<span class="${cls}">${seq[k]}</span>`;
  }
  return `<div class="seq-line"><span class="seq-label">${label}</span><div class="seq-chars">${c}</div></div>`;
}
function matchLine(s1,s2){
  let s='';
  for(let k=0;k<s1.length;k++){
    let sym='&nbsp;';
    if(s1[k]!=='-'&&s2[k]!=='-')sym=s1[k]===s2[k]?'|':'·';
    s+=`<span class="ms">${sym}</span>`;
  }
  return `<div class="match-line">${s}</div>`;
}

// ─────────────────────────────────────────────────────
//  BWT + FM-INDEX
// ─────────────────────────────────────────────────────
function runBWT(){
  const text    = document.getElementById('bwtText').value.trim();
  const pattern = document.getElementById('bwtPattern').value.trim();
  if(!text)   { out('<p class="error-msg">⚠ Ingresa un texto</p>'); return; }
  if(!pattern){ out('<p class="error-msg">⚠ Ingresa un patrón</p>'); return; }

  const T=text+'$', n=T.length;

  // Rotations
  const rots=[];
  for(let i=0;i<n;i++) rots.push({rot:T.slice(i)+T.slice(0,i),origIdx:i});
  const sorted=[...rots].sort((a,b)=>a.rot<b.rot?-1:a.rot>b.rot?1:0);

  const BWT=sorted.map(r=>r.rot[n-1]);
  const F  =sorted.map(r=>r.rot[0]);
  const SA =sorted.map(r=>r.origIdx);

  // Alphabet
  const alphabet=[...new Set(BWT)].sort((a,b)=>a<b?-1:1);

  // C table
  const fCount={};
  for(const c of F) fCount[c]=(fCount[c]||0)+1;
  const sortedAlpha=Object.keys(fCount).sort((a,b)=>a<b?-1:1);
  const C={};let cum=0;
  for(const c of sortedAlpha){C[c]=cum;cum+=fCount[c];}

  // Occ table
  const Occ={};
  for(const c of alphabet) Occ[c]=new Array(n+1).fill(0);
  for(let i=0;i<n;i++){
    for(const c of alphabet) Occ[c][i+1]=Occ[c][i];
    Occ[BWT[i]][i+1]++;
  }

  // Backward search
  const steps=[];
  let lo=0,hi=n,found=true;
  for(let k=pattern.length-1;k>=0;k--){
    const ch=pattern[k];
    if(C[ch]===undefined){
      found=false;
      steps.push({ch,lo,hi,nlo:0,nhi:0,calc:`'${ch}' no está en el alfabeto`,ok:false});
      lo=0;hi=0;break;
    }
    const nlo=C[ch]+Occ[ch][lo], nhi=C[ch]+Occ[ch][hi];
    const calc=`C[${ch}]=${C[ch]}  +  Occ[${ch}][${lo}]=${Occ[ch][lo]}  →  lo=${nlo}  |  Occ[${ch}][${hi}]=${Occ[ch][hi]}  →  hi=${nhi}`;
    steps.push({ch,lo,hi,nlo,nhi,calc,ok:nhi>nlo});
    lo=nlo;hi=nhi;
    if(lo>=hi)found=false;
  }

  const positions=[];
  if(found&&lo<hi){for(let i=lo;i<hi;i++)positions.push(SA[i]+1);positions.sort((a,b)=>a-b);}

  let html='';

  // ── PASO 1: Rotations ──
  html+=`<div class="bwt-section"><h2>PASO 1 — ROTACIONES ORDENADAS Y BWT <span class="algo-badge bwt">BWT</span></h2>
    <p style="color:var(--muted);font-size:.8rem;margin-bottom:12px">
      Texto: <span class="bwt-string"><span class="bwtN">${text}</span></span>
      &nbsp;→&nbsp; Con centinela <strong>$</strong>:
      <span class="bwt-string"><span class="bwtN">${T}</span></span>
    </p>
    <div style="overflow-x:auto"><table class="bwt-rot">
      <tr><th>#</th><th>F (1ª col)</th><th>Rotación completa ordenada</th><th>L / BWT (última)</th><th>SA[i]</th></tr>`;
  for(let i=0;i<n;i++){
    const r=sorted[i];
    const isOrig=(r.rot===T);
    const mid=r.rot.slice(1,n-1);
    html+=`<tr class="${isOrig?'bwt-orig':''}">
      <td class="bwt-idx">${i}</td>
      <td><span class="bwt-f">${F[i]}</span></td>
      <td><span class="bwt-f">${r.rot[0]}</span><span class="bwt-mid">${mid}</span><span class="bwt-l">${r.rot[n-1]}</span>${isOrig?'  <span style="color:var(--blue);font-size:.7rem">← original</span>':''}</td>
      <td><span class="bwt-l">${BWT[i]}</span></td>
      <td class="bwt-idx">${SA[i]}</td>
    </tr>`;
  }
  html+=`</table></div>
    <div style="margin-top:14px;display:flex;gap:20px;flex-wrap:wrap;align-items:center">
      <div><span style="color:var(--muted);font-size:.75rem;display:block;margin-bottom:4px">BWT = última columna (rojo):</span>
        <span class="bwt-string">${BWT.map(c=>`<span class="bwtL">${c}</span>`).join('')}</span></div>
      <div><span style="color:var(--muted);font-size:.75rem;display:block;margin-bottom:4px">F = primera columna (verde):</span>
        <span class="bwt-string">${F.map(c=>`<span class="bwtF">${c}</span>`).join('')}</span></div>
    </div></div>`;

  // ── PASO 2: C + Occ ──
  html+=`<div class="bwt-section"><h2>PASO 2 — TABLAS FM-INDEX: C y OCC</h2>
    <div class="two-col">
      <div>
        <p class="section-title" style="font-size:1rem;margin-bottom:8px">Tabla C — Conteo acumulativo</p>
        <p style="color:var(--muted);font-size:.75rem;margin-bottom:10px">C[c] = # caracteres en T lexicográficamente &lt; c</p>
        <table class="c-table">
          <tr><th>Char</th><th>C[c]</th><th># en F</th></tr>`;
  for(const c of sortedAlpha)
    html+=`<tr><td style="color:var(--accent2);font-weight:700">${c}</td><td class="cv">${C[c]}</td><td style="color:var(--muted)">${fCount[c]}</td></tr>`;
  html+=`</table></div>
      <div>
        <p class="section-title" style="font-size:1rem;margin-bottom:8px">Tabla Occ[c][i]</p>
        <p style="color:var(--muted);font-size:.75rem;margin-bottom:10px">Occ[c][i] = # de <em>c</em> en BWT[0..i-1]</p>
        <div style="overflow-x:auto"><table class="occ-table">
          <tr><th>i</th><th>BWT[i]</th>${alphabet.map(c=>`<th style="color:var(--purple)">Occ[${c}]</th>`).join('')}</tr>`;
  for(let i=0;i<=n;i++){
    html+=`<tr><td class="bwt-idx">${i}</td><td style="color:var(--accent);font-weight:700">${i<n?BWT[i]:'—'}</td>`;
    for(const c of alphabet){const v=Occ[c][i];html+=`<td class="${v>0?'occ-val':'occ-zero'}">${v}</td>`;}
    html+=`</tr>`;
  }
  html+=`</table></div></div></div></div>`;

  // ── PASO 3: Backward search ──
  html+=`<div class="bwt-section"><h2>PASO 3 — BÚSQUEDA HACIA ATRÁS: "${pattern}"</h2>
    <p style="color:var(--muted);font-size:.8rem;margin-bottom:12px">
      Fórmula:&nbsp; <span style="color:var(--blue)">lo = C[c] + Occ[c][lo]</span> &nbsp;|&nbsp;
      <span style="color:var(--blue)">hi = C[c] + Occ[c][hi]</span> &nbsp;|&nbsp;
      Rango inicial: <span style="color:var(--accent2)">[0, ${n})</span>
    </p>
    <table class="search-table">
      <tr><th>Paso</th><th>Carácter</th><th>Rango entrada</th><th>Cálculo detallado</th><th>Rango salida</th><th>Estado</th></tr>`;
  steps.forEach((s,idx)=>{
    const rowCls=s.ok?'found':'not-found';
    html+=`<tr class="${rowCls}">
      <td>${steps.length-idx}</td>
      <td style="color:var(--accent2);font-weight:700;font-size:1.1rem">${s.ch}</td>
      <td class="range-cell">[${s.lo}, ${s.hi})</td>
      <td class="calc-cell">${s.calc}</td>
      <td class="range-cell">${s.ok?`[${s.nlo}, ${s.nhi})`:'∅'}</td>
      <td style="font-weight:700;color:${s.ok?'var(--green)':'var(--accent)'}">${s.ok?'✓ OK':'✗ FALLA'}</td>
    </tr>`;
  });
  html+=`</table>`;

  if(positions.length>0){
    html+=`<div class="positions-result">
      <div class="pr-label">✓ PATRÓN "${pattern}" ENCONTRADO</div>
      <div class="pr-val">Posiciones (1-base): ${positions.join(', ')}</div>
      <div style="color:var(--muted);font-size:.78rem;margin-top:6px">${positions.length} ocurrencia(s) &nbsp;—&nbsp; Rango SA final: [${lo}, ${hi})</div>
    </div>`;
  } else {
    html+=`<div class="positions-result" style="background:rgba(255,60,60,.07);border-color:var(--accent)">
      <div class="pr-label" style="color:var(--accent)">✗ PATRÓN "${pattern}" NO ENCONTRADO</div>
      <div style="color:var(--muted);font-family:'Space Mono',monospace;font-size:.9rem;margin-top:6px">El patrón no aparece en el texto "${text}"</div>
    </div>`;
  }
  html+=`</div>`;

  // ── PASO 4: Highlight in original ──
  if(positions.length>0){
    const plen=pattern.length;
    const posSet=new Set(positions.map(p=>p-1)); // 0-based starts

    // Helper: build highlighted text span array
    function buildHighlighted(text, positions, plen){
      const chars=text.split('');
      // mark which chars are highlighted
      const inMatch=new Array(chars.length).fill(false);
      for(const pos of positions){
        const i0=pos-1;
        for(let k=0;k<plen&&i0+k<chars.length;k++) inMatch[i0+k]=true;
      }
      return chars.map((c,i)=>{
        if(inMatch[i])
          return `<span style="background-color:#FFFF00;color:#000;font-weight:bold;padding:2px 0;border-radius:2px">${c}</span>`;
        return `<span style="color:#e8e8f0">${c}</span>`;
      }).join('');
    }

    // circled numbers helper
    const circled=['①','②','③','④','⑤','⑥','⑦','⑧','⑨','⑩',
                   '⑪','⑫','⑬','⑭','⑮','⑯','⑰','⑱','⑲','⑳'];
    function circleNum(n){ return n<=20 ? circled[n-1] : `(${n})`; }

    html+=`<div class="bwt-section"><h2>PASO 4 — OCURRENCIAS EN EL TEXTO ORIGINAL</h2>`;

    // ── A) Full text with ALL matches highlighted ──
    html+=`<p style="color:var(--muted);font-size:.8rem;margin-bottom:10px">
      Texto completo con patrón <strong style="color:#FFFF00">"${pattern}"</strong> resaltado (fondo amarillo = coincidencia):
    </p>
    <div style="font-family:'Space Mono',monospace;font-size:1.5rem;letter-spacing:.14em;padding:14px 18px;background:#0c1018;border-radius:8px;display:inline-block;line-height:2.2">
      ${buildHighlighted(text, positions, plen)}
    </div>`;

    // ── B) Per-occurrence lines  (B ANA NA ← pos 2) ──
    html+=`<div style="margin-top:20px">
      <p style="color:var(--muted);font-size:.8rem;margin-bottom:10px">Cada ocurrencia por separado:</p>`;
    for(const pos of positions){
      const i0=pos-1;
      const before=text.slice(0,i0);
      const match=text.slice(i0,i0+plen);
      const after=text.slice(i0+plen);
      html+=`<div style="display:flex;align-items:center;gap:14px;margin-bottom:8px;font-family:'Space Mono',monospace;font-size:1.2rem;letter-spacing:.1em">
        <span style="color:#e8e8f0">${before}<span style="background-color:#FFFF00;color:#000;font-weight:bold;padding:2px 3px;border-radius:3px">${match}</span>${after}</span>
        <span style="color:var(--accent);font-size:.8rem;white-space:nowrap">← pos ${pos}</span>
      </div>`;
    }
    html+=`</div>`;

    // ── C) Ruler with arrows at match positions ──
    html+=`<div style="margin-top:20px">
      <p style="color:var(--muted);font-size:.8rem;margin-bottom:8px">Regla de posiciones (↑ = inicio del patrón):</p>
      <div style="font-family:'Space Mono',monospace;display:inline-block;background:#0c1018;border-radius:8px;padding:12px 16px">`;

    // numbers row
    const CW='1.6rem';
    let numRow='<div style="display:flex;gap:0">';
    for(let i=0;i<text.length;i++){
      const isStart=posSet.has(i);
      numRow+=`<div style="width:${CW};text-align:center;color:${isStart?'#ff3c3c':'#5a5a70'};font-size:.8rem;font-weight:${isStart?'700':'400'}">${i+1}${isStart?'↑':''}</div>`;
    }
    numRow+='</div>';

    // text row with highlights
    let textRow='<div style="display:flex;gap:0;margin-top:2px">';
    for(let i=0;i<text.length;i++){
      const inM=positions.some(p=>(p-1)<=i&&i<(p-1)+plen);
      textRow+=`<div style="width:${CW};text-align:center;background-color:${inM?'#FFFF00':'transparent'};color:${inM?'#000':'#e8e8f0'};font-weight:${inM?'bold':'normal'};font-size:1.1rem;border-radius:3px;padding:1px 0">${text[i]}</div>`;
    }
    textRow+='</div>';

    // pattern label row
    let patRow='<div style="display:flex;gap:0;margin-top:4px">';
    for(let i=0;i<text.length;i++){
      const isStart=posSet.has(i);
      const k=i-(isStart?i:Math.max(...[...posSet].filter(s=>s<=i&&s+plen>i),...[-999]));
      patRow+=`<div style="width:${CW};text-align:center;font-size:.75rem;color:#FFFF00">${isStart?pattern[0]:''}</div>`;
    }
    // simpler: just show pattern under each start
    let patRow2='<div style="display:flex;gap:0;margin-top:2px">';
    for(let i=0;i<text.length;i++){
      let ch='';
      for(const pos of positions){
        const i0=pos-1;
        if(i>=i0&&i<i0+plen){ ch=pattern[i-i0]; break; }
      }
      patRow2+=`<div style="width:${CW};text-align:center;font-size:.75rem;color:#FFFF00;font-weight:bold">${ch}</div>`;
    }
    patRow2+='</div>';

    html+=numRow+textRow+patRow2+`</div></div>`;

    // ── D) Circled positions summary ──
    html+=`<div style="margin-top:20px;text-align:center">
      <span style="font-family:'Bebas Neue',sans-serif;font-size:1.2rem;color:var(--muted);letter-spacing:.1em;margin-right:12px">POSICIONES ENCONTRADAS:</span>`;
    for(const pos of positions){
      html+=`<span style="font-size:2.4rem;color:#ff3c3c;font-weight:700;margin:0 6px;text-shadow:0 0 12px rgba(255,60,60,.7)">${circleNum(pos)}</span>`;
    }
    html+=`</div></div>`;
  }

  out(html);
}

function out(html){ document.getElementById('output').innerHTML=html; }

// Auto-run on load
runAlign();
</script>
</body>
</html>